<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tiffin Runner — World’s Best Driver</title>
  <meta property="og:url" content="/" />
  <style>
    :root { --bg:#0b0b0b; --hud:#ffffff; --accent:#ff7a18; }
    html,body{height:100%;}
    body{margin:0;background:#000;color:var(--hud);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
    .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
    canvas{display:block;background:#000;touch-action:manipulation}
    .hud{position:fixed;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:space-between;padding:12px 16px;font-weight:600;letter-spacing:.5px;text-shadow:0 1px 2px rgba(0,0,0,.6)}
    .hud .right{display:flex;gap:12px}
    .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.25);padding:6px 10px;border-radius:999px}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;text-align:center;padding:24px}
    .overlay.show{display:flex}
    .card{background:#111;border:1px solid #333;padding:18px 20px;border-radius:14px;max-width:520px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card h2{margin:.2rem 0 0;font-size:1.25rem}
    .card p{opacity:.85;margin:.35rem 0 .75rem}
    .card .btns{display:flex;gap:10px;justify-content:center;margin-top:.5rem}
    button{background:#fff;border:0;border-radius:12px;padding:.6rem 1rem;cursor:pointer;font-weight:700}
    button.secondary{background:#222;color:#fff;border:1px solid #444}
    .tip{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);opacity:.75;font-size:.9rem}
  </style>
</head>
<body>
  <div class="wrap"><canvas id="game"></canvas></div>
  <div class="hud">
    <div class="left pill">World’s Best Driver — Tiffin Run</div>
    <div class="right">
      <div class="pill">Time: <span id="time">0.0</span>s</div>
      <div class="pill">Score: <span id="score">0</span></div>
    </div>
  </div>
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-live="assertive">
    <div class="card">
      <h2 id="title">Game Over</h2>
      <p id="subtitle">You hit an obstacle.</p>
      <div class="btns">
        <button id="retry">Restart (R)</button>
        <button id="home" class="secondary">Home</button>
      </div>
    </div>
  </div>
  <div class="tip">Press Space/▲ or Tap to Jump — Avoid corn stalks & potholes — Survive 30s to win</div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Assets
    const bgImg = new Image();
    bgImg.src = 'tiffin-ohio-road-side-cornfields.jpg';
    const playerImg = new Image();
    playerImg.src = 'the-worlds-best-driver-is-in-tiffin-ohio.png';

    // Home URL (from og:url or '/')
    const HOME_URL = document.querySelector('meta[property="og:url"]')?.getAttribute('content') || '/';

    // Sizing
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize(){
      const w = Math.min(window.innerWidth, 1100);
      const h = Math.min(window.innerHeight, 520);
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w+'px';
      canvas.style.height = h+'px';
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // World
    let groundY = 0; // computed after resize
    function computeGround(){
      groundY = canvas.height * 0.78;
    }
    computeGround();

    // Player
    const player = {
      x: canvas.width*0.18,
      y: 0,
      w: 90*DPR, h: 90*DPR,
      vy: 0,
      onGround: true
    };
    function resetPlayer(){
      player.x = canvas.width*0.18;
      player.w = 90*DPR; player.h = 90*DPR;
      player.y = groundY - player.h + 2;
      player.vy = 0;
      player.onGround = true;
    }
    resetPlayer();

    // Physics
    let speed = 400 * DPR;     // px/s for obstacle travel
    let gravity = 2600 * DPR;  // px/s^2
    let jumpVy = -900 * DPR;   // initial jump velocity

    // Obstacles
    let obstacles = []; // {x,y,w,h,type:'corn'|'pothole'}
    let nextSpawn = 0;
    function spawnObstacle(){
      const type = Math.random() < 0.6 ? 'corn' : 'pothole';
      if(type === 'corn'){
        const w = (24 + Math.random()*14) * DPR;
        const h = (60 + Math.random()*55) * DPR;
        obstacles.push({type, x: canvas.width + 20*DPR, w, h, y: groundY - h});
      } else {
        const w = (70 + Math.random()*60) * DPR;
        const h = (18 + Math.random()*10) * DPR; // shallow hole
        obstacles.push({type, x: canvas.width + 20*DPR, w, h, y: groundY - h + Math.max(0, (player.h*0.05))});
      }
      // next spawn in 700-1700ms, tighter over time
      nextSpawn = now + 700 + Math.random()*1000;
    }

    // Timer & game state
    let startTime=0, now=0, last=0, elapsed=0, score=0, running=false, won=false;
    const targetSurvive = 30.0; // seconds
    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const titleEl = document.getElementById('title');
    const subEl = document.getElementById('subtitle');
    const retryBtn = document.getElementById('retry');
    const homeBtn = document.getElementById('home');

    function start(){
      obstacles.length = 0;
      speed = 400 * DPR;
      gravity = 2600 * DPR;
      jumpVy = -900 * DPR;
      resetPlayer();
      startTime = performance.now();
      last = startTime;
      now = startTime;
      elapsed = 0; score = 0; won = false;
      running = true;
      overlay.classList.remove('show');
      requestAnimationFrame(loop);
    }

    function endGame(win=false){
      running = false;
      won = win;
      titleEl.textContent = win ? 'Congratulations!' : 'Game Over';
      subEl.textContent = win ? 'You survived 30 seconds! Taking you home…' : 'You hit an obstacle.';
      overlay.classList.add('show');
      if (win) {
        setTimeout(()=>{ window.location.href = HOME_URL; }, 1600);
      }
    }

    // Input
    function jump(){
      if (!running) return;
      if (player.onGround){
        player.vy = jumpVy;
        player.onGround = false;
      }
    }
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW'){ e.preventDefault(); jump(); }
      if (e.code === 'KeyR'){ e.preventDefault(); start(); }
    });
    window.addEventListener('pointerdown', (e)=>{
      jump();
    }, {passive:true});
    retryBtn.addEventListener('click', start);
    homeBtn.addEventListener('click', ()=> window.location.href = HOME_URL);

    // Parallax background
    let bgOffset = 0;
    function drawBackground(dt){
      if (!bgImg.complete) { ctx.fillStyle = '#1b1b1b'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      const speedPx = speed * 0.25;
      bgOffset = (bgOffset + speedPx * dt) % (bgImg.width || canvas.width);
      // Draw two images to tile horizontally
      const ratio = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
      const w = (bgImg.width * ratio)|0;
      const h = (bgImg.height * ratio)|0;
      const y = (canvas.height - h) >> 1;
      const x1 = -bgOffset % w;
      ctx.drawImage(bgImg, x1, y, w, h);
      ctx.drawImage(bgImg, x1 + w, y, w, h);
    }

    function drawGround(){
      // simple road line
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      ctx.fillStyle = '#c0c0c0';
      const laneY = groundY + 14*DPR;
      for (let x = -40*DPR; x < canvas.width; x += 120*DPR){
        ctx.fillRect(x, laneY, 60*DPR, 4*DPR);
      }
    }

    function drawPlayer(){
      if (playerImg.complete){
        ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = '#ff9';
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }
    }

    function drawObstacle(o){
      if (o.type === 'corn'){
        // stalk
        ctx.fillStyle = '#2ecc40';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // leaves accent
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(o.x + o.w*0.6, o.y + o.h*0.2, o.w*0.25, o.h*0.15);
        ctx.fillRect(o.x + o.w*0.3, o.y + o.h*0.55, o.w*0.3, o.h*0.15);
      } else {
        // pothole (dark ellipse)
        ctx.beginPath();
        const cx = o.x + o.w/2, cy = o.y + o.h/2, rx = o.w/2, ry = o.h/2;
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        ctx.fillStyle = '#1d1d1d';
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2*DPR;
        ctx.stroke();
      }
    }

    function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function update(dt){
      // Speed ramps slightly
      speed += 6 * dt * DPR;

      // Player physics
      player.vy += gravity * dt;
      player.y += player.vy * dt;
      if (player.y + player.h >= groundY){
        player.y = groundY - player.h;
        player.vy = 0;
        player.onGround = true;
      }

      // Obstacles
      if (now >= nextSpawn) spawnObstacle();
      for (let i = obstacles.length-1; i >= 0; i--){
        const o = obstacles[i];
        o.x -= speed * dt;
        if (o.x + o.w < -10) obstacles.splice(i,1);
        // collision
        if (o.type === 'corn'){
          if (rectsOverlap(player.x+player.w*0.15, player.y+player.h*0.15, player.w*0.7, player.h*0.85, o.x, o.y, o.w, o.h)){
            endGame(false); return;
          }
        } else {
          // pothole: collide if feet are low and x overlaps
          const playerFeet = player.y + player.h;
          const touchingGround = playerFeet >= groundY - 4*DPR;
          if (touchingGround && rectsOverlap(player.x+player.w*0.15, groundY-4*DPR, player.w*0.7, 6*DPR, o.x, o.y, o.w, o.h)){
            endGame(false); return;
          }
        }
      }

      // Time/score
      elapsed = (now - startTime)/1000;
      score += dt * 100;
      timeEl.textContent = elapsed.toFixed(1);
      scoreEl.textContent = Math.floor(score);

      if (elapsed >= targetSurvive){
        endGame(true);
      }
    }

    function loop(t){
      if (!running) return;
      now = t;
      const dt = Math.min(0.032, (now - last)/1000);
      last = now;

      // recompute ground on resize differences
      computeGround();

      drawBackground(dt);
      drawGround();
      drawPlayer();
      for (const o of obstacles) drawObstacle(o);
      update(dt);

      requestAnimationFrame(loop);
    }

    // Start when images have at least begun loading
    start();
  })();
  </script>
</body>
</html>
