<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tiffin Runner — World’s Best Driver (v2b)</title>
  <meta property="og:url" content="/" />
  <style>
    :root { --bg:#0b0b0b; --hud:#ffffff; --accent:#ff7a18; }
    html,body{height:100%;}
    body{margin:0;background:#000;color:var(--hud);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
    .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
    canvas{display:block;background:#000;touch-action:manipulation}
    .hud{position:fixed;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:space-between;padding:12px 16px;font-weight:600;letter-spacing:.5px;text-shadow:0 1px 2px rgba(0,0,0,.6)}
    .hud .right{display:flex;gap:12px}
    .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.25);padding:6px 10px;border-radius:999px}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;text-align:center;padding:24px}
    .overlay.show{display:flex}
    .card{background:#111;border:1px solid #333;padding:18px 20px;border-radius:14px;max-width:520px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card h2{margin:.2rem 0 0;font-size:1.25rem}
    .card p{opacity:.9;margin:.35rem 0 .75rem}
    .card .btns{display:flex;gap:10px;justify-content:center;margin-top:.5rem}
    button{background:#fff;border:0;border-radius:12px;padding:.6rem 1rem;cursor:pointer;font-weight:700}
    .tip{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);opacity:.8;font-size:.9rem}
  </style>
</head>
<body>
  <div class="wrap"><canvas id="game"></canvas></div>
  <div class="hud">
    <div class="left pill">World’s Best Driver — Tiffin Run</div>
    <div class="right">
      <div class="pill">Time: <span id="time">0.0</span>s</div>
      <div class="pill">Score: <span id="score">0</span></div>
    </div>
  </div>
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-live="assertive">
    <div class="card">
      <h2 id="title">Game Over</h2>
      <p id="subtitle">You hit an obstacle.</p>
      <div class="btns">
        <button id="retry">Restart (R)</button>
      </div>
    </div>
  </div>
  <div class="tip">Press Space/▲ or Tap to Jump — Avoid corn stalks & potholes — Survive 30s to win</div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Assets (set crossOrigin to avoid canvas taint if files are served from CDN)
    const bgImg = new Image(); bgImg.crossOrigin = 'anonymous';
    bgImg.src = 'tiffin-ohio-road-side-cornfields.jpg';
    const playerImg = new Image(); playerImg.crossOrigin = 'anonymous';
    playerImg.src = 'the-worlds-best-driver-is-in-tiffin-ohio.png';
    const cornImg = new Image(); cornImg.crossOrigin = 'anonymous';
    cornImg.src = 'pixelated-corn-in-tiffin-ohio.jpg'; // non-transparent, we chroma-key but gracefully fallback

    // Home URL (from og:url or '/')
    const HOME_URL = document.querySelector('meta[property=\"og:url\"]')?.getAttribute('content') || '/';

    // Sizing
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize(){
      let w = Math.min(window.innerWidth || 800, 1100);
      let h = Math.min(window.innerHeight || 400, 520);
      if (w < 300) w = 800; if (h < 200) h = 400; // fallback if browser reported 0
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w+'px';
      canvas.style.height = h+'px';
      computeGround();
      resetPlayer();
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // World
    let groundY = 0;
    function computeGround(){ groundY = Math.max(80, canvas.height * 0.78); }

    // Player
    const player = { x: 0, y: 0, w: 90*DPR, h: 90*DPR, vy: 0, onGround: true };
    function resetPlayer(){
      player.x = canvas.width*0.18;
      player.w = 90*DPR; player.h = 90*DPR;
      player.y = groundY - player.h + 2;
      player.vy = 0; player.onGround = true;
    }

    // Physics
    let speed = 400 * DPR;
    let gravity = 2600 * DPR;
    let jumpVy = -900 * DPR;

    // Obstacles
    let obstacles = [];
    let nextSpawn = 0;
    let cause = null;

    // Corn sprite (processed to remove gray background) with try/catch fallback
    let cornSprite = null;
    function makeChromaSprite(img) {
      try {
        const w = img.naturalWidth, h = img.naturalHeight;
        if (!w || !h) return null;
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const octx = off.getContext('2d');
        octx.drawImage(img, 0, 0);
        const data = octx.getImageData(0,0,w,h);
        const px = data.data;
        for (let i=0; i<px.length; i+=4) {
          const r=px[i], g=px[i+1], b=px[i+2];
          const max = Math.max(r,g,b), min = Math.min(r,g,b);
          const sat = max ? (max-min)/max : 0;
          const val = max/255;
          if (sat < 0.12 && val > 0.75) px[i+3] = 0;
        }
        octx.putImageData(data,0,0);
        return off;
      } catch (e) {
        console.warn('Chroma-key failed, using unprocessed corn image.', e);
        return null;
      }
    }
    function ensureCornSprite(){
      if (cornSprite !== null) return cornSprite;
      cornSprite = makeChromaSprite(cornImg) || cornImg; // fallback to original image
      return cornSprite;
    }

    function spawnObstacle(){
      const type = Math.random() < 0.6 ? 'corn' : 'pothole';
      if(type === 'corn'){
        const sprite = ensureCornSprite();
        const aspect = sprite && sprite.width && sprite.height ? (sprite.width/sprite.height) : (40/100);
        const baseH = (70 + Math.random()*70) * DPR;
        const w = baseH * aspect, h = baseH;
        obstacles.push({type, x: canvas.width + 20*DPR, w, h, y: groundY - h});
      } else {
        const w = (70 + Math.random()*60) * DPR;
        const h = (18 + Math.random()*10) * DPR;
        obstacles.push({type, x: canvas.width + 20*DPR, w, h, y: groundY - h + Math.max(0, (player.h*0.05))});
      }
      nextSpawn = now + 700 + Math.random()*1000;
    }

    // Timer & game state
    let startTime=0, now=0, last=0, elapsed=0, score=0, running=false, won=false;
    const targetSurvive = 30.0; // seconds
    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const titleEl = document.getElementById('title');
    const subEl = document.getElementById('subtitle');
    const retryBtn = document.getElementById('retry');

    function start(){
      obstacles.length = 0;
      speed = 400 * DPR; gravity = 2600 * DPR; jumpVy = -900 * DPR;
      cause = null; resetPlayer();
      startTime = performance.now(); last = startTime; now = startTime;
      elapsed = 0; score = 0; won = false;
      overlay.classList.remove('show');
      running = true;
      requestAnimationFrame(loop);
    }

    function endGame(win=false, why=null){
      running = false; won = win;
      titleEl.textContent = win ? 'Congratulations!' : 'Game Over';
      subEl.textContent = win ? 'You survived 30 seconds! Taking you home…'
                              : (why === 'pothole' ? 'You hit a pothole.' : 'You hit a corn stalk.');
      overlay.classList.add('show');
      if (win) setTimeout(()=>{ window.location.href = HOME_URL; }, 1600);
    }

    // Input
    function jump(){
      if (!running) return;
      if (player.onGround){ player.vy = jumpVy; player.onGround = false; }
    }
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW'){ e.preventDefault(); jump(); }
      if (e.code === 'KeyR'){ e.preventDefault(); start(); }
    });
    window.addEventListener('pointerdown', ()=>{ jump(); }, {passive:true});
    retryBtn.addEventListener('click', start);

    // Parallax background
    let bgOffset = 0;
    function drawBackground(dt){
      if (!bgImg.complete || !bgImg.naturalWidth) {
        ctx.fillStyle = '#101010'; ctx.fillRect(0,0,canvas.width,canvas.height);
        return;
      }
      const speedPx = speed * 0.25;
      bgOffset = (bgOffset + speedPx * dt) % (bgImg.width || canvas.width);
      const ratio = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
      const w = (bgImg.width * ratio)|0;
      const h = (bgImg.height * ratio)|0;
      const y = (canvas.height - h) >> 1;
      const x1 = -bgOffset % w;
      ctx.drawImage(bgImg, x1, y, w, h);
      ctx.drawImage(bgImg, x1 + w, y, w, h);
    }

    function drawGround(){
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      ctx.fillStyle = '#c0c0c0';
      const laneY = groundY + 14*DPR;
      for (let x = -40*DPR; x < canvas.width; x += 120*DPR){
        ctx.fillRect(x, laneY, 60*DPR, 4*DPR);
      }
    }

    function drawPlayer(){
      if (playerImg.complete && playerImg.naturalWidth){
        ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = '#ff9';
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }
    }

    function drawObstacle(o){
      if (o.type === 'corn'){
        const sprite = ensureCornSprite();
        if (sprite && sprite.width) ctx.drawImage(sprite, o.x, o.y, o.w, o.h);
        else { ctx.fillStyle = '#2ecc40'; ctx.fillRect(o.x, o.y, o.w, o.h); }
      } else {
        ctx.beginPath();
        const cx = o.x + o.w/2, cy = o.y + o.h/2, rx = o.w/2, ry = o.h/2;
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        ctx.fillStyle = '#1d1d1d'; ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2*DPR; ctx.stroke();
      }
    }

    function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function update(dt){
      speed += 6 * dt * DPR;

      player.vy += gravity * dt;
      player.y += player.vy * dt;
      if (player.y + player.h >= groundY){
        player.y = groundY - player.h; player.vy = 0; player.onGround = true;
      }

      if (now >= nextSpawn) spawnObstacle();
      for (let i = obstacles.length-1; i >= 0; i--){
        const o = obstacles[i];
        o.x -= speed * dt;
        if (o.x + o.w < -10) obstacles.splice(i,1);
        if (o.type === 'corn'){
          if (rectsOverlap(player.x+player.w*0.15, player.y+player.h*0.15, player.w*0.7, player.h*0.85, o.x, o.y, o.w, o.h)){
            endGame(false, 'corn'); return;
          }
        } else {
          const touchingGround = (player.y + player.h) >= groundY - 4*DPR;
          if (touchingGround && rectsOverlap(player.x+player.w*0.15, groundY-4*DPR, player.w*0.7, 6*DPR, o.x, o.y, o.w, o.h)){
            endGame(false, 'pothole'); return;
          }
        }
      }

      elapsed = (now - startTime)/1000;
      score += dt * 100;
      document.getElementById('time').textContent = elapsed.toFixed(1);
      document.getElementById('score').textContent = Math.floor(score);

      if (elapsed >= 30.0) endGame(true);
    }

    function loop(t){
      if (!running) return;
      now = t; const dt = Math.min(0.032, (now - last)/1000); last = now;
      drawBackground(dt); drawGround();
      for (const o of obstacles) drawObstacle(o);
      drawPlayer(); update(dt);
      requestAnimationFrame(loop);
    }

    // Always start after load, regardless of image status (prevents "black screen")
    let forcedStart = false;
    window.addEventListener('load', ()=>{ if (!forcedStart){ forcedStart = true; start(); }});
    // Extra safeguard: if still not started in 600ms, start anyway.
    setTimeout(()=>{ if (!forcedStart){ forcedStart = true; start(); }}, 600);
  })();
  </script>
</body>
</html>
